在 Redis 2.8 以前，从节点向主节点发送 sync 命令请求同步数据，此时的同步方式是全量复制。
在 Redis 2.8 及以后，从节点可以发送 psync 命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。后文介绍以 Redis 2.8 及以后版本为例。
全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。
部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。
需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。

全量复制
	Redis 通过 psync 命令进行全量复制的过程如下：
	从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制；具体判断过程需要在讲述了部分复制原理后再介绍。
	主节点收到全量复制的命令后，执行 bgsave，在后台生成 RDB 文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令
	主节点的 bgsave 执行完成后，将 RDB 文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的 RDB 文件，将数据库状态更新至主节点执行 bgsave 时的数据库状态。
	主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态
	如果从节点开启了 AOF，则会触发 bgrewriteaof 的执行，从而保证 AOF 文件更新至主节点的最新状态。
其中，有几点需要注意：
	从节点接收了来自主节点的 XXXX个字节的数据。
	从节点在载入主节点的数据之前要先将老数据清除。
	从节点在同步完数据后，调用了 bgrewriteaof。
通过全量复制的过程可以看出，全量复制是非常重型的操作：
	主节点通过 bgsave 命令 fork 子进程进行 RDB 持久化，该过程是非常消耗 CPU、内存(页表复制)、硬盘 IO 的；关于 bgsave 的性能问题，可以参考深入学习Redis（2）：持久化。
	主节点通过网络将 RDB 文件发送给从节点，对主从节点的带宽都会带来很大的消耗。
	从节点清空老数据、载入新 RDB 文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行 bgrewriteaof，也会带来额外的消耗。

部分复制
	由于全量复制在主节点数据量较大时效率太低，因此 Redis 2.8 开始提供部分复制，用于处理网络中断时的数据同步。
部分复制的实现，依赖于三个重要的概念：
	复制偏移量：主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数。
	主节点每次向从节点传播 N 个字节数据时，主节点的 offset 增加 N；从节点每次收到主节点传来的 N 个字节数据时，从节点的 offset 增加 N。
	offset 用于判断主从节点的数据库状态是否一致：如果二者 offset 相同，则一致；如果 offset 不同，则不一致，此时可以根据两个 offset 找出从节点缺少的那部分数据。
	例如，如果主节点的 offset 是 1000，而从节点的 offset 是 500，那么部分复制就需要将 offset 为 501-1000 的数据传递给从节点。
	而 offset 为 501-1000 的数据存储的位置，就是下面要介绍的复制积压缓冲区。
复制积压缓冲区：复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小 1MB。
	当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。
	在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。
	由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。
	由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点 offset 的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。
	反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)。
	例如如果网络中断的平均时间是 60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为 100KB，则复制积压缓冲区的平均需求为 6MB。
	保险起见，可以设置为 12MB，来保证绝大多数断线情况都可以使用部分复制。
	从节点将 offset 发送给主节点后，主节点根据 offset 和缓冲区大小决定能否执行部分复制：
		如果 offset 偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制。
		如果 offset 偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。
服务器运行 ID(runid)：每个 Redis 节点(无论主从)，在启动时都会自动生成一个随机 ID(每次启动都不一样)，由 40 个随机的十六进制字符组成；runid 用来唯一识别一个 Redis 节点。
	通过 info Server 命令，可以查看节点的 runid：
	主从节点初次复制时，主节点将自己的 runid 发送给从节点，从节点将这个 runid 保存起来；当断线重连时，从节点会将这个 runid 发送给主节点。
	主节点根据 runid 判断能否进行部分复制：
		如果从节点保存的 runid 与主节点现在的 runid 相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看 offset 和复制积压缓冲区的情况)。
		如果从节点保存的 runid 与主节点现在的 runid 不同，说明从节点在断线前同步的 Redis 节点并不是当前的主节点，只能进行全量复制。
psync 命令的执行：在了解了复制偏移量、复制积压缓冲区、节点运行 id 之后，本节将介绍 psync 命令的参数和返回值，从而说明 psync 命令执行过程中，主从节点是如何确定使用全量复制还是部分复制的。
	首先，从节点根据当前状态，决定如何调用 psync 命令：
		如果从节点之前未执行过 slaveof 或最近执行了 slaveof no one，则从节点发送命令为 psync ? -1，向主节点请求全量复制。
		如果从节点之前执行了 slaveof，则发送命令为 psync <runid> <offset>，其中 runid 为上次复制的主节点的 runid，offset 为上次复制截止时从节点保存的复制偏移量。
	主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制：
		如果主节点版本低于 Redis 2.8，则返回 -ERR 回复，此时从节点重新发送 sync 命令执行全量复制。
		如果主节点版本够新，且 runid 与从节点发送的 runid 相同，且从节点发送的 offset 之后的数据在复制积压缓冲区中都存在，则回复 +CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可。
		如果主节点版本够新，但是 runid 与从节点发送的 runid 不同，或从节点发送的 offset 之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复 +FULLRESYNC <runid> <offset>，表示要进行全量复制。
		其中 runid 表示主节点当前的 runid，offset 表示主节点当前的 offset，从节点保存这两个值，以备使用。
部分复制演示：在下面的演示中，网络中断几分钟后恢复，断开连接的主从节点进行了部分复制；为了便于模拟网络中断，本例中的主从节点在局域网中的两台机器上。
	网络中断一段时间后，主节点和从节点都会发现失去了与对方的连接（关于主从节点对超时的判断机制，后面会有说明）。
	此后，从节点便开始执行对主节点的重连，由于此时网络还没有恢复，重连失败，从节点会一直尝试重连。
	网络恢复后，从节点连接主节点成功，并请求进行部分复制，主节点接收请求后，二者进行部分复制以同步数据。