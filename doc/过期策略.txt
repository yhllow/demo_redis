比如你Redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？
还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?
回答：Redis 采用的是定期删除+惰性删除策略。
为什么不用定时删除策略
	定时删除，用一个定时器来负责监视 Key，过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。
	在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 Key，因此没有采用这一策略。

定期删除+惰性删除是如何工作
	定期删除，Redis 默认每个100ms检查，是否有过期的Key，有过期Key则删除。
	需要说明的是，Redis不是每个100ms将所有的Key检查一次，而是随机抽取进行检查(如果每隔100ms，全部Key进行检查，Redis岂不是卡死)。
	因此，如果只采用定期删除策略，会导致很多Key到时间没有删除。于是，惰性删除派上用场。
	也就是说在你获取某个Key的时候，Redis会检查一下，这个Key如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。

采用定期删除+惰性删除就没其他问题了么?
	不是的，如果定期删除没删除Key。然后你也没即时去请求Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。
	在 redis.conf 中有一行配置：
	# maxmemory-policy volatile-lru：该配置就是配内存淘汰策略的：
	noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。
	allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。
	allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。
	volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存
	储的时候才用。不推荐。
	volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。
	volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。